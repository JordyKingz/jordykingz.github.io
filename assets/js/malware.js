(function () {
    const baseConfig = window.malwareConfig || {};
    const config = Object.assign({}, baseConfig, {
        presignEndpoint: (typeof baseConfig.presignEndpoint === 'string' && baseConfig.presignEndpoint.trim().length > 0)
            ? baseConfig.presignEndpoint
            : '/api/presign'
    });

    document.addEventListener('DOMContentLoaded', () => {
        setupUploadForm();
        loadSamples();
    });

    /**
     * -----------------------------
     *  UPLOAD FORM SETUP
     * -----------------------------
     */
    function setupUploadForm() {
        const form = document.getElementById('malware-upload-form');
        const dropzone = document.getElementById('malware-dropzone');
        const fileInput = document.getElementById('malware-file');
        const statusEl = document.getElementById('upload-status');
        const notesInput = document.getElementById('malware-notes');
        const contactInput = document.getElementById('malware-contact');

        if (!form || !fileInput || !dropzone) return;

        /** ----- DRAG & DROP ----- */

        dropzone.addEventListener('click', () => fileInput.click());

        dropzone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropzone.classList.add('dragging');
        });

        ['dragleave', 'dragend', 'drop'].forEach((type) => {
            dropzone.addEventListener(type, () => dropzone.classList.remove('dragging'));
        });

        dropzone.addEventListener('drop', (event) => {
            event.preventDefault();
            if (!event.dataTransfer) return;
            if (event.dataTransfer.files.length > 0) {
                fileInput.files = event.dataTransfer.files;
                renderSelectedFile();
            }
        });

        fileInput.addEventListener('change', renderSelectedFile);

        function renderSelectedFile() {
            const details = dropzone.querySelector('.dropzone-hint');
            if (!fileInput.files || fileInput.files.length === 0) {
                dropzone.classList.remove('has-file');
                if (details) {
                    details.textContent = 'The file is streamed to my Spaces bucket over HTTPS. No logs, no judgment.';
                }
                return;
            }
            const file = fileInput.files[0];
            dropzone.classList.add('has-file');
            if (details) {
                details.textContent = `${file.name} • ${formatBytes(file.size)}`;
            }
        }

        /** ----- HANDLE SUBMIT ----- */

        form.addEventListener('submit', async (event) => {
            event.preventDefault();

            if (!fileInput.files || fileInput.files.length === 0) {
                updateStatus('Select a file before uploading.', 'error');
                return;
            }

            if (!config.presignEndpoint) {
                updateStatus('Upload API is not configured. Set `malwareConfig.presignEndpoint`.', 'error');
                return;
            }

            const file = fileInput.files[0];
            setUploading(true);
            updateStatus('Preparing upload…');

            try {
                const timestamp = Date.now();
                const sanitizedName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
                const filename = `uploads/${timestamp}_${sanitizedName}`;

                updateStatus('Getting upload URL…');
                const presign = await getPresignedUrl(filename, file.type);

                if (!presign || !presign.url) {
                    throw new Error('Presign endpoint returned no URL.');
                }

                updateStatus('Uploading file…');
                await uploadToSpaces(file, presign.url, (percent) => {
                    updateStatus(`Uploading… ${Math.round(percent)}%`);
                });

                if (config.metadataEndpoint) {
                    updateStatus('Saving metadata…');
                    await saveMetadata({
                        filename,
                        originalName: file.name,
                        size: file.size,
                        type: file.type,
                        notes: notesInput?.value || '',
                        contact: contactInput?.value || '',
                        uploadedAt: new Date().toISOString()
                    });
                }

                updateStatus('Upload complete. Thanks for the sample!', 'success');
                form.reset();
                dropzone.classList.remove('has-file');

                if (notesInput) notesInput.value = '';
                if (contactInput) contactInput.value = '';

                loadSamples(true);

            } catch (err) {
                console.error(err);
                updateStatus(err.message || 'Upload failed.', 'error');
            } finally {
                setUploading(false);
            }
        });

        function setUploading(isUploading) {
            const button = form.querySelector('button');
            if (!button) return;
            button.disabled = isUploading;
            button.classList.toggle('is-uploading', isUploading);
        }

        function updateStatus(message, state) {
            if (!statusEl) return;
            statusEl.textContent = message;
            statusEl.classList.remove('is-error', 'is-success');
            if (state === 'error') statusEl.classList.add('is-error');
            if (state === 'success') statusEl.classList.add('is-success');
        }
    }

    /**
     * -----------------------------
     *  PRESIGNED URL HELPERS
     * -----------------------------
     */

    async function getPresignedUrl(filename, contentType) {
        const requestBody = {
            filename,
            type: 'PUT',
            duration: '30m',
            contentType: contentType || 'application/octet-stream'
        };

        console.log('Requesting presigned URL:', requestBody);
        console.log('Endpoint:', config.presignEndpoint);

        const response = await fetch(config.presignEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': config.bearerToken ? `Basic ${config.bearerToken}` : ''
            },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();
        console.log('Response:', response.status, data);
        
        if (!response.ok) {
            throw new Error(data?.body?.error || data?.error || 'Failed to get presigned URL');
        }

        return data.body || data;
    }

    async function getPresignedUrlForDownload(filename) {
        const response = await fetch(config.presignEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': config.bearerToken ? `Basic ${config.bearerToken}` : ''
            },
            body: JSON.stringify({
                filename,
                type: 'GET',
                duration: '30m'
            })
        });

        const data = await response.json();
        if (!response.ok) {
            throw new Error(data?.body?.error || data?.error || 'Failed to get download URL');
        }

        return data.body || data;
    }

    /**
     * -----------------------------
     *  SPACES UPLOADER
     * -----------------------------
     */

    async function uploadToSpaces(file, presignedUrl, onProgress) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            console.log('Starting upload to presigned URL');
            console.log('File type:', file.type);
            console.log('File size:', file.size);
            
            xhr.open('PUT', presignedUrl);

            // Important: When using presigned URLs, the Content-Type must match
            // what was specified when generating the presigned URL
            if (file.type) {
                xhr.setRequestHeader('Content-Type', file.type);
            }
            
            // Set CORS mode
            xhr.withCredentials = false;

            xhr.onload = () => {
                console.log('Upload response:', xhr.status, xhr.statusText);
                console.log('Response headers:', xhr.getAllResponseHeaders());
                
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve();
                } else {
                    console.error('Upload failed. Response:', xhr.responseText);
                    reject(new Error(`Upload failed (HTTP ${xhr.status})`));
                }
            };

            xhr.onerror = () => {
                console.error('Network error during upload');
                reject(new Error('Network error during upload.'));
            };

            xhr.upload.addEventListener('progress', (event) => {
                if (event.lengthComputable && typeof onProgress === 'function') {
                    const percent = (event.loaded / event.total) * 100;
                    onProgress(Math.min(percent, 100));
                }
            });

            xhr.send(file);
        });
    }

    /**
     * -----------------------------
     *  OPTIONAL: SAVE METADATA
     * -----------------------------
     */

    async function saveMetadata(metadata) {
        const response = await fetch(config.metadataEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': config.bearerToken ? `Bearer ${config.bearerToken}` : ''
            },
            body: JSON.stringify(metadata),
        });

        if (!response.ok) {
            console.warn('Failed to save metadata:', response.status);
        }
    }

    /**
     * -----------------------------
     *  SAMPLE GALLERY
     * -----------------------------
     */

    async function loadSamples(forceRefresh) {
        const container = document.getElementById('malware-sample-list');
        const template = document.getElementById('malware-sample-template');
        if (!container || !template) return;

        container.classList.add('is-loading');
        container.innerHTML = '';

        const samples = await fetchSamples(forceRefresh);
        container.classList.remove('is-loading');

        if (!samples || samples.length === 0) {
            container.innerHTML = '<p class="empty-state">No community samples yet. Be the first to drop one.</p>';
            return;
        }

        samples.forEach((sample) => {
            const card = template.content.cloneNode(true);
            const statusEl = card.querySelector('.sample-status');
            const titleEl = card.querySelector('h3');
            const metaEl = card.querySelector('.sample-meta');
            const notesEl = card.querySelector('.sample-notes');
            const actionsEl = card.querySelector('.sample-actions');

            const status = (sample.status || 'Queued').toLowerCase();
            statusEl.textContent = sample.status || 'Queued';
            statusEl.classList.add('status-tag', `status-${status.replace(/\s+/g, '-')}`);

            titleEl.textContent = sample.name || sample.key || 'Untitled sample';

            const metaBits = [];
            if (sample.submitted_at) {
                const dt = new Date(sample.submitted_at);
                if (!isNaN(dt)) {
                    metaBits.push(dt.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }));
                }
            }
            if (sample.size_bytes) {
                metaBits.push(formatBytes(sample.size_bytes));
            }
            metaEl.textContent = metaBits.join(' • ');

            if (sample.notes) notesEl.textContent = sample.notes;
            else notesEl.style.display = 'none';

            actionsEl.innerHTML = '';

            if (config.presignEndpoint && sample.key) {
                const link = createActionLink('#', 'View raw sample');
                link.addEventListener('click', async (e) => {
                    e.preventDefault();
                    try {
                        const presign = await getPresignedUrlForDownload(sample.key);
                        if (presign.url) window.open(presign.url, '_blank');
                    } catch (err) {
                        alert('Failed to get download URL.');
                    }
                });
                actionsEl.appendChild(link);
            } else if (sample.file_url) {
                actionsEl.appendChild(createActionLink(sample.file_url, 'View raw sample'));
            }

            container.appendChild(card);
        });
    }

    async function fetchSamples(forceRefresh) {
        if (!config.samplesFeed) return config.fallbackSamples || [];

        try {
            const response = await fetch(config.samplesFeed, {
                cache: forceRefresh ? 'reload' : 'default',
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) throw new Error('Failed manifest fetch');

            const payload = await response.json();
            return Array.isArray(payload.samples) ? payload.samples : payload;

        } catch (err) {
            console.warn('Falling back to fallbackSamples', err);
            return config.fallbackSamples || [];
        }
    }

    /**
     * -----------------------------
     *  HELPERS
     * -----------------------------
     */

    function formatBytes(bytes) {
        if (!Number.isFinite(bytes)) return '';
        if (bytes === 0) return '0 B';

        const units = ['B', 'KB', 'MB', 'GB'];
        const index = Math.floor(Math.log(bytes) / Math.log(1024));
        const value = bytes / Math.pow(1024, index);

        return `${value.toFixed(value >= 10 ? 0 : 1)} ${units[index]}`;
    }

    function createActionLink(href, label) {
        const a = document.createElement('a');
        a.href = href;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = label;
        return a;
    }

})();
